---
title: "Using Subconscious"
description: "More details on using Subconscious"
icon: "play"
---

import ResearchPreview from "/snippets/research-preview.mdx";
import ExampleNoTools from "/snippets/example-no-tools.mdx";
import ExampleOneTool from "/snippets/example-one-tool.mdx";
import ExampleMultipleTools from "/snippets/example-multiple-tools.mdx";
import ExampleStreaming from "/snippets/example-streaming.mdx";

<ResearchPreview />

Getting started with Subconscious is straightforward: **set your goals, make your tools, and call the Subconscious API**. The platform handles the complex reasoning and tool orchestration for you.

## Basic Workflow

1. **Define your prompt** - Describe what you want the agent to accomplish
2. **Create your tools** - Define the functions your agent can use (optional)
3. **Call the API** - Send your request and get intelligent results

## Code Examples

### Example 1: Calling an Agent with No Tools

The simplest use case - just send a prompt and get a response.

<ExampleNoTools />

### Example 2: Calling an Agent with One Tool

This example illustrates how tools are defined and passed to the API.

<ExampleOneTool />

### Example 3: Calling an Agent with Multiple Tools

This example shows how multiple tools can be composed for more advanced agents.

<ExampleMultipleTools />

## Streaming

All of the examples above use the sync API with `await_completion: True`. When you want to see responses in real-time as they're generated, you can use streaming:

<ExampleStreaming />

## Async workflows

For longâ€‘running tasks or when you need stronger durability guarantees, you can use async workflows with polling and webhooks. See the [Async jobs and webhooks](/platform/async-jobs-and-webhooks) guide for detailed examples of:

- Fire and forget patterns
- Polling with custom options
- Webhook subscriptions
- Cancellation
- Error handling

## Interpreting Results

When using the Subconscious SDK, the agent's reasoning and final answer are contained within the `run.result.answer` field as a JSON string. This field contains structured JSON that represents the agent's reasoning process and final output.

### Response Structure

The object follows this TypeScript interface:

```typescript
export interface ModelResponse {
  reasoning: Task[];
  answer: string;
}

export interface Task {
  thought?: string;
  title?: string;
  tooluse?: ToolCall;
  subtasks?: Task[];
  conclusion?: string;
}

export interface ToolCall {
  parameters: any;
  tool_name: string;
  tool_result: any;
}
```

### Response Fields Explained

- **`reasoning`**: An array of `Task` objects that show the agent's step-by-step reasoning process
- **`answer`**: The final, human-readable answer to your original prompt

### Task Structure

Each task in the reasoning array can contain:

- **`thought`**: The agent's internal reasoning about what to do next
- **`title`**: A descriptive title for this reasoning step
- **`tooluse`**: Details about a tool call, including:
  - `parameters`: The input parameters sent to the tool
  - `tool_name`: The name of the tool that was called
  - `tool_result`: The result returned by the tool
- **`subtasks`**: Nested tasks showing more detailed reasoning steps
- **`conclusion`**: The agent's conclusion after completing this reasoning step

### Example Response

A simplified `run.result.answer` response will contain JSON like this:

```json
{
  "reasoning": [
    {
      "title": "Analyzing the request",
      "thought": "I need to search for information about Tesla's stock performance",
      "tooluse": {
        "tool_name": "web_search",
        "parameters": {
          "query": "Tesla stock performance this week"
        },
        "tool_result": {
          "results": [
            {
              "title": "Tesla Stock Analysis",
              "snippet": "Tesla's stock has shown..."
            }
          ]
        }
      },
      "conclusion": "Found relevant information about Tesla's stock performance"
    }
  ],
  "answer": "Based on my search, Tesla's stock performance this week shows..."
}
```

### Other Response Fields

The complete API response also includes:

- **`usage`** - Token usage information for the request
- **`model`** - The model that was used for the completion

This structured response format allows you to:

- **Understand** how your agent arrives at its final answer
- **Debug** your agent's reasoning process
- **Monitor** tool usage and results
- **Optimize** your tool configurations
