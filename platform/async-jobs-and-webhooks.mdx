---
title: "Async jobs and webhooks"
description: "Run long‑running agent work reliably and get notified on completion"
---

import ResearchPreview from "/snippets/research-preview.mdx";
import AsyncPolling from "/snippets/async-polling.mdx";
import AsyncWebhook from "/snippets/async-webhook.mdx";

<ResearchPreview />

## Why async?

Streaming responses are great when you want a human in the loop, but some workloads:

- Run for a long time (many tool calls, large searches, multi‑step plans).
- Must be durable (you care that they finish, not that you watched every token).
- Need to fan out results to other systems (pipelines, CRMs, warehouses, etc.).

For those cases we expose an async pipeline with:

- **Async jobs** – you submit work, we enqueue and process it in the background.
- **Polling** – you can check the status and result at any time.
- **Webhooks** – we can call back into your system when the job finishes.

You get the same agent behavior as the sync API, but with better durability and control.

## High‑level architecture

At a high level, the async path looks like this:

1. You call `client.run()` without `await_completion` (or set it to `False`) with your usual engine + input.
2. We create an async job and enqueue it into an internal queue.
3. A dedicated worker service pulls jobs from the queue and runs them against the engine.
4. On completion we:
   - update the job status, and
   - optionally enqueue one or more webhook deliveries.
5. You:
   - poll the status using `client.get()` or `client.wait()`, or
   - receive a webhook at your configured callback URL.

You never talk to the queue or workers directly; you only use the SDK.

## Async jobs & polling

The core entrypoint is:

- `client.run()` with `await_completion: False`

You send the same input you would send to the sync API, but instead of waiting for the model to finish we:

- return quickly with:
  - a `run_id`,
  - `status: "queued"`, and
  - the run object.
- do the work in the background.

To check on the job later, you use:

- `client.get(run_id)` to check status
- `client.wait(run_id, options)` to poll until completion

The status payload contains:

- `status`: `queued | running | succeeded | failed | canceled | timed_out`
- `run_id`: run identifier
- `engine`
- `result` (when completed)
- `error` (when failed)
- timestamps

This polling contract is the "source of truth" for async job state.

<AsyncPolling />

## Webhooks

Polling is ideal when you have a single client watching a single job. For automation and integrations, it's more natural for us to notify you when jobs finish.

You have two options:

1. **Ephemeral webhooks** – you pass a `callbackUrl` in the run options, and we call that URL once when the job finishes.
2. **Persistent subscriptions** – you register webhook subscriptions for events like `run.completed` or `run.failed`, and we fan out to all matching subscribers.

In both cases, webhook deliveries:

- are queued and retried with exponential backoff,
- use timeouts to avoid hanging on bad receivers,
- eventually land in a DLQ if they cannot be delivered,
- are stored in our database so you can inspect their status.

<AsyncWebhook />

## When to use what

Use **sync + streaming** when:

- a human is watching the response,
- you care more about interactivity than durability.

Use **async + polling** when:

- the job may take a while,
- you have a client that can easily poll (dashboard, CLI, cron job),
- you want a simple way to check status and surface errors.

Use **async + webhooks** when:

- you want to plug agents into other systems (HubSpot, Salesforce, workflow engines),
- you need a reliable, push‑based notification that work finished,
- you want a clear audit trail of deliveries and retries.

You can mix these patterns: for example, submit async jobs from a backend, poll in a dashboard, and use webhooks to trigger follow‑up automations.

## Related docs

- **Quickstart** – see the async polling examples in the SDK documentation.
- **SDK Reference** – `client.run()`, `client.get()`, `client.wait()`, `client.cancel()`, and webhook configuration.
- **Logs** – how to inspect worker logs, queue age, and delivery errors.
